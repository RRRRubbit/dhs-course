Programme for lab-3

library ieee;
use ieee.std_logic_1164.all;

entity PWM_driver_E is
  generic(
    pwm_bit : integer := 14
    );
  port(
    reset_n                         : in  std_logic;
    clk                             : in  std_logic;
    pwm_base_period                 : in  integer range 0 to 2**(pwm_bit)-1;
    pwm_duty_cycle                  : in  integer range 0 to 2**(pwm_bit)-1;
    pwm_control                     : in  std_logic_vector(7 downto 0);
    pwm_cycle_done                    : out std_logic;  -- new values at inputs are now used
    pwm_out1, pwm_out2, pwm_n_sleep : out std_logic);
end PWM_driver_E;

architecture rtl of PWM_driver_E is
--ADD SIGNALS
signal pwm_out1_s, pwm_out2_s, pwm_n_sleep_s : std_logic;
signal set_counter : std_logic;
signal max_count : integer range 0 to 2**(pwm_bit)-1; 
signal counter : integer range 0 to 2**(pwm_bit)-1;
signal en : std_logic ;
signal inv : std_logic ;
signal brk : std_logic ;
signal ack_s : std_logic ;
signal duty : integer range 0 to 2**(pwm_bit)-1;
begin

--ADD THE FUNCTIONALITY FOR THE PWM DRIVER
sys : process (clk, reset_n)
        begin
max_count <= pwm_base_period;
en <= pwm_control(0);
inv <= pwm_control(1);
brk <= pwm_control(2);
if reset_n = '0' then
en <= '0';
inv <= '0';
brk <= '0';
max_count <= 0;
ack_s <= '0';	
 counter <= 0;
 elsif rising_edge (clk) then
if set_counter = '1' then
 counter <=0;
end if;
if counter < max_count then
counter <= counter + 1;
ack_s <= '0'; 
 else
 counter <=0;
ack_s <= '1'; 
end if;
end if;
    end process;
fsm : process(clk,reset_n, en, inv, brk)
begin
set_counter <= '0';
duty <= pwm_duty_cycle ;

if reset_n = '0'  then 
pwm_out1_s <='Z';
pwm_out2_s <= 'Z'; 
pwm_n_sleep_s <= '0';
 
elsif rising_edge (clk) then
1 if en = '1' then
pwm_n_sleep_s <= '1';

2 if brk='0' then
3 if counter < duty then
pwm_out1_s <= '1';

4 if inv = '1' then
pwm_out2_s <= '0';
else
pwm_out2_s <= '1';
end if;
else
pwm_out1_s <= '0';

5 if inv = '1' then
pwm_out2_s <= '0';
else
pwm_out2_s <= '1';
end if;
end if;
else
pwm_out1_s <='1';
pwm_out2_s <= '1';	
end if;
else
pwm_out1_s <='Z';
pwm_out2_s <= 'Z'; 
pwm_n_sleep_s <= '0';
end if;
end if;
end process;
pwm_out1	<=pwm_out1_s;
pwm_out2	<=pwm_out2_s;
pwm_n_sleep	<=pwm_n_sleep_s;
pwm_cycle_done	<=ack_s;
end rtl;